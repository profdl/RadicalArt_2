<!DOCTYPE html>
<html>
<head>
    <title>Site Link Graph</title>
    <meta charset="utf-8">
    <script>
        // Detect if we're running on GitHub Pages or locally
        window.isGitHubPages = window.location.hostname.includes('github.io');
        window.BASE_PATH = window.isGitHubPages ? '/RadicalArt_2/' : '/';
        document.write(`<base href="${window.BASE_PATH}">`);
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #graph {
            width: 100vw;
            height: 100vh;
            background-color: white;
            position: relative;
        }
        .node rect {
            fill: white;
            stroke: #333;
            stroke-width: 1px;
        }
        .node text {
            font-size: 12px;
            font-family: sans-serif;
            pointer-events: none;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .tooltip {
            position: absolute;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
        #controls {
            display: none; /* Hide the search controls */
        }
        #controls button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .nav-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .nav-button {
            width: 32px;
            height: 32px;
            border: none;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 18px;
            transition: all 0.2s ease;
            font-family: Arial, sans-serif;
        }
        .nav-button.small-icon {
            font-size: 14px;
        }
        .nav-button:hover {
            background: #f0f0f0;
            color: #333;
        }
        .nav-divider {
            height: 1px;
            background: #ddd;
            margin: 4px 0;
        }
        .nav-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .search-box {
            margin-top: 10px;
            position: relative;
        }
        #search {
            width: 200px;
            padding: 5px 25px 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        #search:focus {
            outline: none;
            border-color: #66afe9;
            box-shadow: 0 0 5px rgba(102, 175, 233, 0.5);
        }
        .search-box::after {
            content: '×';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
            cursor: pointer;
            font-size: 16px;
            display: none;
        }
        .search-box.has-text::after {
            display: block;
        }
        #search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 5px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .search-result-item {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:hover {
            background-color: #f5f5f5;
        }
        .search-result-highlight {
            background-color: #fff3cd;
            padding: 0 2px;
        }
        .search-count {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            display: none;
        }
        #preview-panel {
            position: fixed;
            top: 20px; /* Move to top */
            left: 20px; /* Keep left alignment */
            width: 500px; /* Increased from 300px */
            height: 400px;
            background: rgba(255, 255, 255, 0.95); /* Changed to rgba for transparency */
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            overflow: hidden;
            z-index: 1000;
            transition: none; /* Remove transition for smoother dragging */
            resize: both;
            min-width: 300px; /* Increased from 200px */
            min-height: 200px;
            max-width: 95vw;
            max-height: calc(95vh - 20px); /* Adjust for top spacing */
        }

        #preview-header {
            padding: 10px;
            background: rgba(245, 245, 245, 0.95); /* Changed to rgba for transparency */
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move; /* Indicate draggable */
            user-select: none; /* Prevent text selection while dragging */
        }
        #preview-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default; /* Reset cursor for controls */
        }
        #preview-controls button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 5px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            z-index: 1; /* Ensure buttons are clickable */
        }
        #preview-controls button:hover {
            color: #000;
            background: #f0f0f0;
            border-radius: 4px;
        }
        #preview-title {
            margin: 0;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        #preview-content {
            height: calc(100% - 40px);
            overflow: auto;
            padding-right: 8px;
            padding-bottom: 15px; /* Add space for resize handle */
        }
        .preview-container {
            transform-origin: top left;
            padding: 10px;
            min-width: 100%;
            width: max-content;
        }
        .preview-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100% - 40px);
            font-style: italic;
            color: #666;
        }
        .checkbox-control {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .checkbox-control input[type="checkbox"] {
            margin: 0;
        }
        .slider-control {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-control input[type="range"] {
            flex: 1;
        }
        .slider-control label {
            font-size: 12px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="graph"></div>
    <div id="controls">
        <div class="search-box">
            <input type="text" id="search" placeholder="Search pages...">
            <div class="search-count"></div>
            <div id="search-results"></div>
        </div>
    </div>
    <div class="nav-controls">
        <div class="nav-group">
            <button class="nav-button" id="zoomIn" title="Zoom In">+</button>
            <button class="nav-button" id="zoomOut" title="Zoom Out">−</button>
        </div>
        <div class="nav-divider"></div>
        <div class="nav-group">
            <button class="nav-button" id="resetView" title="Reset View">⌂</button>
            <button class="nav-button small-icon" id="fitScreen" title="Fit to Screen">⤧</button>
        </div>
    </div>
    <div id="preview-panel">
        <div id="preview-header">
            <h3 id="preview-title"></h3>
                            <div id="preview-controls">
                    <button id="preview-open" title="Open in New Tab">↗</button>
                    <button id="preview-close" title="Close">×</button>
                </div>
        </div>
        <div id="preview-content"></div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="image-loader.js"></script>
    <script>
        // Use the global variables defined in the head
        const { isGitHubPages, BASE_PATH } = window;

        function getCleanName(path) {
            // Remove .html extension
            path = path.replace('.html', '');
            
            // Split path into parts
            const parts = path.split('/');
            
            // If it ends with index, use the parent directory name
            if (parts[parts.length - 1] === 'index') {
                return parts[parts.length - 2] || parts[0];
            }
            
            // Otherwise use the last meaningful part
            const lastPart = parts[parts.length - 1];
            const name = lastPart === '' ? parts[parts.length - 2] : lastPart;
            
            // Special case for radical_art (case insensitive)
            if (name.toLowerCase() === 'radical_art') {
                return 'Radical Art';
            }
            
            return name;
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        async function createGraph() {
            const data = await fetch(BASE_PATH + 'graph_data.json').then(response => response.json());
            
            // Get accurate window dimensions
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Calculate node degrees and connections
            const nodeDegrees = {};
            const nodeConnections = {};
            data.nodes.forEach(node => {
                nodeDegrees[node.id] = 0;
                nodeConnections[node.id] = new Set();
                // Add clean name to node data
                node.cleanName = capitalizeFirstLetter(getCleanName(node.name));
            });
            
            // Build connection map and calculate degrees
            data.links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                nodeDegrees[sourceId]++;
                nodeDegrees[targetId]++;
                nodeConnections[sourceId].add(targetId);
                nodeConnections[targetId].add(sourceId);
            });

            // Use Radical Art node as the hub
            const hubNode = data.nodes.find(node => node.id === 435);
            
            // Initialize positions using a hierarchical layout
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) * 0.4;
            
            // Place hub node at center
            hubNode.x = centerX;
            hubNode.y = centerY;
            
            // Create layers based on distance from hub
            const layers = new Map();
            const visited = new Set([hubNode.id]);
            let currentLayer = [hubNode.id];
            let layerIndex = 0;
            
            while (currentLayer.length > 0) {
                layers.set(layerIndex, currentLayer);
                const nextLayer = [];
                
                currentLayer.forEach(nodeId => {
                    nodeConnections[nodeId].forEach(connectedId => {
                        if (!visited.has(connectedId)) {
                            visited.add(connectedId);
                            nextLayer.push(connectedId);
                        }
                    });
                });
                
                currentLayer = nextLayer;
                layerIndex++;
            }
            
            // Position nodes in each layer
            layers.forEach((layerNodes, layer) => {
                const layerRadius = (layer + 1) * (maxRadius / layers.size);
                const angleStep = (2 * Math.PI) / layerNodes.length;
                
                layerNodes.forEach((nodeId, index) => {
                    const node = data.nodes.find(n => n.id === nodeId);
                    if (node) {
                        const angle = index * angleStep;
                        node.x = centerX + layerRadius * Math.cos(angle);
                        node.y = centerY + layerRadius * Math.sin(angle);
                    }
                });
            });
            
            // Highlighted node names (lowercase for comparison)
            const highlightedNodeNames = [
                "concept", "algorithm", "mechanics", "process", "destruction",
                "nothing", "something", "anything", "everything", "life",
                "radical art"  // Updated to match the new display name
            ];
            data.nodes.forEach(node => {
                node.isHighlighted = highlightedNodeNames.includes(node.cleanName.toLowerCase());
                // Add special styling for Radical Art node
                node.isRadicalArt = node.cleanName.toLowerCase() === "radical art";
            });
            data.links.forEach(link => {
                nodeDegrees[link.source]++;
                nodeDegrees[link.target]++;
            });
            
            // Store original nodes and links
            const originalNodes = [...data.nodes];
            const originalLinks = [...data.links];
            
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', zoomed)
                .filter(event => {
                    // Allow zoom on wheel events
                    if (event.type === 'wheel') return true;
                    // Allow pan on drag events
                    if (event.type === 'mousedown') return true;
                    // For clicks, we'll handle them separately
                    return false;
                });
            
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .call(zoom);
            
            const g = svg.append('g');

            // Set initial zoom level
            const initialScale = 0.25;  // More zoomed out initial view (changed from 0.5)
            svg.call(zoom.transform, d3.zoomIdentity.scale(initialScale));
            
            let simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id))
                .force('charge', d3.forceManyBody().strength(-1000))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeSize(d).width / 1.5));
            
            function updateGraph() {
                // Always filter out the home page
                let currentNodes = originalNodes.filter(n => n.name !== 'index.html');
                
                let currentLinks = originalLinks.filter(l => {
                    const sourceNode = originalNodes.find(n => n.id === (typeof l.source === 'object' ? l.source.id : l.source));
                    const targetNode = originalNodes.find(n => n.id === (typeof l.target === 'object' ? l.target.id : l.target));
                    return sourceNode && targetNode && 
                           sourceNode.name !== 'index.html' && 
                           targetNode.name !== 'index.html';
                });

                // Update the simulation with new data
                simulation.nodes(currentNodes);
                simulation.force('link').links(currentLinks);
                
                // Update the visual elements
                const link = g.selectAll('.link')
                    .data(currentLinks);
                
                link.exit().remove();
                
                link.enter()
                    .append('line')
                    .attr('class', 'link')
                    .merge(link);
                
                const node = g.selectAll('.node')
                    .data(currentNodes, d => d.id);
                
                node.exit().remove();
                
                const nodeEnter = node.enter()
                    .append('g')
                    .attr('class', 'node')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                nodeEnter.each(function(d) {
                    const g = d3.select(this);
                    const size = getNodeSize(d);
                    
                    g.append('rect')
                        .attr('width', size.width)
                        .attr('height', size.height)
                        .attr('x', -size.width / 2)
                        .attr('y', -size.height / 2)
                        .style('fill', d => {
                            if (d.isRadicalArt) return '#ff0000';  // Red background for Radical Art
                            return d.isHighlighted ? 'black' : 'white';
                        })
                        .style('stroke', d => d.isHighlighted ? '#222' : stringToColor(d.name.split('/')[0] || d.name))
                        .style('stroke-width', d => d.isHighlighted ? '3px' : '1px');
                    
                    g.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .text(d => d.cleanName)
                        .style('font-size', calculateFontSize(d))
                        .style('fill', d => d.isHighlighted ? 'white' : '#191970');
                });

                // Update existing nodes
                node.select('rect')
                    .attr('width', d => getNodeSize(d).width)
                    .attr('height', d => getNodeSize(d).height)
                    .attr('x', d => -getNodeSize(d).width / 2)
                    .attr('y', d => -getNodeSize(d).height / 2)
                    .style('fill', d => {
                        if (d.isRadicalArt) return '#ff0000';  // Red background for Radical Art
                        return d.isHighlighted ? 'black' : 'white';
                    })
                    .style('stroke', d => d.isHighlighted ? '#222' : stringToColor(d.name.split('/')[0] || d.name))
                    .style('stroke-width', d => d.isHighlighted ? '3px' : '1px');

                node.select('text')
                    .text(d => d.cleanName)
                    .style('font-size', d => calculateFontSize(d))
                    .style('fill', d => d.isHighlighted ? 'white' : '#191970');

                // Update node event handlers
                const allNodes = node.merge(nodeEnter);
                const allLinks = link.merge(link.enter());

                allNodes.on('mouseover', function(event, d) {
                    // Only update highlights if no node is selected
                    if (!selectedNodeId) {
                        updateNodeHighlights(d.id);
                    }
                })
                .on('mouseout', function() {
                    // Only reset highlights if no node is selected
                    if (!selectedNodeId) {
                        updateNodeHighlights(null);
                    }
                })
                .on('click', function(event, d) {
                    event.stopPropagation(); // Prevent click from reaching background
                    
                    // Toggle selection
                    if (selectedNodeId === d.id) {
                        selectedNodeId = null;
                        updateNodeHighlights(null);
                        d3.select('#preview-panel').style('display', 'none');
                        // Reset node styling
                        g.selectAll('.node rect')
                            .style('stroke', d => d.isHighlighted ? '#222' : stringToColor(d.name.split('/')[0] || d.name))
                            .style('stroke-width', d => d.isHighlighted ? '3px' : '1px');
                    } else {
                        selectedNodeId = d.id;
                        updateNodeHighlights(d.id);
                        
                        // Set red border for selected node
                        g.selectAll('.node rect')
                            .style('stroke', n => n.id === d.id ? '#ff0000' : (n.isHighlighted ? '#222' : stringToColor(n.name.split('/')[0] || n.name)))
                            .style('stroke-width', n => n.id === d.id ? '3px' : (n.isHighlighted ? '3px' : '1px'));
                        
                        // Find all connected nodes
                        const connectedNodes = new Set();
                        currentLinks.forEach(link => {
                            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                            if (sourceId === d.id) connectedNodes.add(targetId);
                            if (targetId === d.id) connectedNodes.add(sourceId);
                        });
                        // Add the clicked node itself
                        connectedNodes.add(d.id);
                        
                        // Zoom to fit all connected nodes
                        zoomToFitNodes(Array.from(connectedNodes));
                        
                        // Show preview panel
                        showPreview(d);
                    }
                });

                // Restart the simulation
                simulation.alpha(1).restart();
            }

            // Move the showPreview function definition here
            function showPreview(d) {
                const previewPanel = d3.select('#preview-panel');
                const previewTitle = d3.select('#preview-title');
                const previewContent = d3.select('#preview-content');
                const previewHeader = d3.select('#preview-header');
                
                // Set the title
                previewTitle.text(d.cleanName);
                
                // Show loading state
                previewContent.html('<div class="preview-loading">Loading preview...</div>');
                previewPanel.style('display', 'block');

                // Function to fit content to panel width
                function fitContentToWidth() {
                    const container = previewContent.select('.preview-container');
                    if (!container.empty()) {
                        const contentWidth = container.node().scrollWidth;
                        const panelWidth = previewContent.node().clientWidth;
                        const scale = Math.min(1, (panelWidth - 20) / contentWidth); // 20px padding
                        container
                            .style('transform', `scale(${scale})`)
                            .style('transform-origin', 'top left');
                    }
                }

                // Store initial size if not already stored
                if (!previewPanel.attr('data-initial-width')) {
                    previewPanel.attr('data-initial-width', '300px')
                        .attr('data-initial-height', '400px');
                }

                // Dragging functionality
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;

                function dragStart(e) {
                    // Only allow dragging from header and not from control buttons
                    if (e.target.closest('#preview-controls')) return;
                    
                    const panel = previewPanel.node();
                    const rect = panel.getBoundingClientRect();
                    
                    // Get current position considering any previous dragging
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    // Store current position as offset
                    xOffset = e.clientX - rect.left;
                    yOffset = e.clientY - rect.top;
                    
                    if (e.target === previewHeader.node() || e.target === previewTitle.node()) {
                        isDragging = true;
                    }
                }

                function dragEnd() {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                }

                function drag(e) {
                    if (!isDragging) return;

                    e.preventDefault();
                    
                    // Calculate the new position
                    currentX = e.clientX - xOffset;
                    currentY = e.clientY - yOffset;

                    // Apply bounds checking
                    const panel = previewPanel.node();
                    const rect = panel.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;

                    // Keep at least 20px of the panel visible on each edge
                    currentX = Math.min(Math.max(currentX, -rect.width + 20), viewportWidth - 20);
                    currentY = Math.min(Math.max(currentY, 0), viewportHeight - 20);

                    // Update position
                    previewPanel
                        .style('left', currentX + 'px')
                        .style('right', null) // Remove right positioning when dragging
                        .style('top', currentY + 'px');
                }

                // Add drag event listeners
                previewHeader
                    .on('mousedown', dragStart)
                    .on('mouseup', dragEnd)
                    .on('mouseleave', dragEnd);

                d3.select('body')
                    .on('mousemove', drag)
                    .on('mouseup', dragEnd);

                // Handle the file path - show home.html for Radical Art node
                const filePath = d.isRadicalArt ? 'home.html' : d.name;
                
                // Add open in new tab functionality
                d3.select('#preview-open').on('click', () => {
                    const fullUrl = window.location.origin + BASE_PATH + filePath;
                    window.open(fullUrl, '_blank');
                });
                
                // Add click handler to preview content to open in new tab
                previewContent.style('cursor', 'pointer');
                previewContent.on('click', (event) => {
                    // Don't trigger if clicking on a link or if dragging
                    if (event.target.closest('a') || isDragging) return;
                    
                    const fullUrl = window.location.origin + BASE_PATH + filePath;
                    window.open(fullUrl, '_blank');
                });
                
                // Add close button functionality
                d3.select('#preview-close').on('click', () => {
                    previewPanel
                        .style('display', 'none')
                        .classed('expanded', false)
                        // Reset position when closing
                        .style('left', '20px')
                        .style('right', null)
                        .style('top', '150px');
                    
                    // Reset to initial size when closing
                    previewPanel
                        .style('width', previewPanel.attr('data-initial-width'))
                        .style('height', previewPanel.attr('data-initial-height'));
                    
                    // Reset drag state
                    isDragging = false;
                    xOffset = 0;
                    yOffset = 0;
                });

                // Update ResizeObserver to handle content scaling
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        // Scale content to fit new width
                        fitContentToWidth();
                    }
                });

                // Observe the preview panel
                resizeObserver.observe(previewPanel.node());

                // First try to fetch the content
                fetch(BASE_PATH + filePath)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`File not found: ${d.name}`);
                        }
                        return response.text();
                    })
                    .then(content => {
                        // Create a container for the content
                        const container = document.createElement('div');
                        container.className = 'preview-container';
                        container.style.width = 'max-content';
                        container.style.minWidth = '100%';

                        try {
                            // Parse the content with DOMParser to manipulate it before inserting
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            
                            // Remove blacktext.html references before they can trigger requests
                            doc.querySelectorAll('link[href*="blacktext.html"]').forEach(el => el.remove());
                            
                            // Add default styles
                            const defaultStyle = document.createElement('style');
                            defaultStyle.textContent = `
                                body {
                                    font-family: Arial, sans-serif;
                                    color: #000;
                                    background: #fff;
                                    margin: 0;
                                    padding: 10px;
                                    min-width: fit-content;
                                }
                                a {
                                    color: #0066cc;
                                    text-decoration: none;
                                }
                                a:hover {
                                    text-decoration: underline;
                                }
                                img {
                                    max-width: 100%;
                                    height: auto;
                                }
                                .broken-image {
                                    display: inline-block;
                                    background: #f0f0f0;
                                    border: 1px dashed #999;
                                }
                            `;
                            doc.head.appendChild(defaultStyle);

                            // Process all links to make them functional
                            doc.querySelectorAll('a').forEach(link => {
                                const href = link.getAttribute('href');
                                if (href) {
                                    // Keep the original href for reference
                                    link.setAttribute('data-original-href', href);
                                    
                                    // Remove the href attribute to prevent default navigation
                                    link.removeAttribute('href');
                                    
                                    // Add click handler with proper event handling
                                    link.addEventListener('click', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        
                                        // Handle relative URLs
                                        let fullUrl;
                                        if (href.startsWith('http://') || href.startsWith('https://')) {
                                            fullUrl = href;
                                        } else {
                                            // Consistently handle paths relative to BASE_PATH
                                            let relativePath = href;
                                            if (relativePath.startsWith('/')) {
                                                relativePath = relativePath.substring(1);
                                            }
                                            
                                            // Construct full URL
                                            fullUrl = window.location.origin + BASE_PATH + relativePath;
                                            console.log('Opening link:', fullUrl);
                                        }
                                        
                                        // Open in new tab with a slight delay to ensure event handling completes
                                        setTimeout(() => {
                                            window.open(fullUrl, '_blank');
                                        }, 10);
                                        
                                        return false;
                                    });
                                    
                                    // Add pointer cursor to show it's clickable despite removed href
                                    link.style.cursor = 'pointer';
                                    link.style.textDecoration = 'underline';
                                    link.style.color = '#0066cc';
                                }
                            });

                            // Process all images
                            doc.querySelectorAll('img').forEach(img => {
                                const src = img.getAttribute('src');
                                if (src) {
                                    // Keep the original src for reference
                                    img.setAttribute('data-original-src', src);
                                    
                                    // If src is relative, make it relative to the current page
                                    if (!src.startsWith('http://') && !src.startsWith('https://')) {
                                        const currentPath = d.name.split('/').slice(0, -1).join('/');
                                        const relativeSrc = currentPath ? `${currentPath}/${src}` : src;
                                        img.setAttribute('src', `${BASE_PATH}${relativeSrc}`);
                                    }
                                    
                                    // Add error handling that uses our handleResourceError function
                                    img.onerror = function() {
                                        handleResourceError(this, this.getAttribute('data-original-src'));
                                    };
                                }
                            });

                            // Set the HTML content
                            container.innerHTML = doc.documentElement.innerHTML;
                            
                            // Clear the preview content and add the container
                            previewContent.html('');
                            previewContent.node().appendChild(container);

                            // Initial fit to width
                            fitContentToWidth();


                        } catch (error) {
                            console.error('Error processing preview content:', error);
                            showErrorPreview(d.name, error.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading preview:', error);
                        showErrorPreview(d.name, error.message);
                    });
            }

            function showErrorPreview(filename, errorMessage) {
                const previewContent = d3.select('#preview-content');
                previewContent.html(`
                    <div class="preview-error" style="padding: 20px; text-align: center;">
                        <h3 style="color: #666;">Unable to Preview File</h3>
                        <p style="color: #888;">${filename}</p>
                        <p style="color: #999; font-style: italic;">${errorMessage}</p>
                        <div style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 5px;">
                            <p style="margin: 0; color: #666;">This file might be:</p>
                            <ul style="list-style: none; padding: 0; margin: 10px 0;">
                                <li style="color: #888;">• Not accessible from the current location</li>
                                <li style="color: #888;">• Moved or deleted</li>
                                <li style="color: #888;">• Requiring special permissions</li>
                            </ul>
                        </div>
                    </div>
                `);
            }

            function handleResourceError(element, originalSrc) {
                if (!originalSrc) return;
                
                // Get the image name and check if it's in a concept path
                const imgName = originalSrc.split('/').pop();
                
                // Build the list of paths to try, starting with most likely locations
                const alternativePaths = [
                    // Artist-specific paths first
                    `${BASE_PATH}anything/OpenForm/Rauschenberg/${imgName}`,
                    `${BASE_PATH}images/${imgName}`,
                    `${BASE_PATH}img/${imgName}`,
                    `${BASE_PATH}assets/${imgName}`,
                    `${BASE_PATH}gif/buttons/${imgName}`,
                    `${BASE_PATH}gif/kinetiek/${imgName}`,
                    `${BASE_PATH}gif/natuur/${imgName}`,
                    `${BASE_PATH}gif/${imgName}`,
                    `${BASE_PATH}${imgName}`
                ];

                // Add artist-specific paths if the image name contains artist names
                const artistPaths = {
                    'Rauschenberg': 'anything/OpenForm/Rauschenberg',
                    'Agam': 'Agam',
                    'PaulTalman': 'PaulTalman',
                    'JanHenderikse': 'JanHenderikse',
                    'ReinerKallhardt': 'ReinerKallhardt'
                };

                Object.entries(artistPaths).forEach(([artist, path]) => {
                    if (imgName.includes(artist)) {
                        alternativePaths.unshift(`${BASE_PATH}${path}/${imgName}`);
                    }
                });
                
                // Try each path in sequence
                async function tryNextPath(index = 0) {
                    if (index >= alternativePaths.length) {
                        console.error('Could not find image:', imgName);
                        element.outerHTML = `<div class="broken-image">Image not found: ${imgName}</div>`;
                        return;
                    }
                    
                    const path = alternativePaths[index];
                    try {
                        const response = await fetch(path, { method: 'HEAD' });
                        if (response.ok) {
                            element.src = path;
                            return;
                        }
                    } catch (error) {
                        // Continue to next path
                    }
                    await tryNextPath(index + 1);
                }
                
                tryNextPath();
            }

            // Add search functionality
            const searchInput = d3.select('#search');
            const searchBox = d3.select('.search-box');
            const searchCount = d3.select('.search-count');
            const searchResultsContainer = d3.select('#search-results');

            // Clear search when clicking the × button
            searchBox.on('click', function(event) {
                const target = event.target;
                if (target.tagName !== 'INPUT' && searchInput.node().value) {
                    searchInput.node().value = '';
                    searchInput.node().dispatchEvent(new Event('input'));
                    event.stopPropagation();
                }
            });

            searchInput.on('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                // Update search box clear button visibility
                searchBox.classed('has-text', searchTerm.length > 0);
                
                // If search is empty, restore all nodes to original state
                if (!searchTerm) {
                    restoreGraphState();
                    return;
                }

                // Get all nodes that match the search term
                const matchingNodes = new Set();
                const matchingResults = [];

                // Search through nodes
                g.selectAll('.node').each(function(d) {
                    const nodeText = d.name.toLowerCase();
                    const cleanName = d.cleanName.toLowerCase();
                    if (nodeText.includes(searchTerm) || cleanName.includes(searchTerm)) {
                        matchingNodes.add(d.id);
                        matchingResults.push({
                            id: d.id,
                            name: d.name,
                            cleanName: d.cleanName,
                            node: d
                        });
                    }
                });

                // Update search count
                const matchCount = matchingNodes.size;
                searchCount.text(`Found ${matchCount} match${matchCount !== 1 ? 'es' : ''}`)
                    .style('display', 'block');

                // Update graph visualization
                updateGraphWithSearch(matchingNodes);

                // Update search results dropdown
                updateSearchResults(matchingResults, searchTerm);
            });

            function restoreGraphState() {
                // Reset node visibility and styling
                g.selectAll('.node')
                    .style('display', 'block')
                    .attr('opacity', 1)
                    .each(function() {
                        const rect = d3.select(this).select('rect');
                        const originalColor = rect.attr('data-original-color');
                        if (originalColor) {
                            rect.style('stroke', originalColor)
                                .style('stroke-width', '1px')
                                .attr('data-original-color', null);
                        }
                    });

                // Reset link visibility
                g.selectAll('.link')
                    .style('display', 'block')
                    .attr('opacity', 0.6);

                // Hide search UI elements
                searchCount.style('display', 'none');
                searchResultsContainer.style('display', 'none');
            }

            function updateGraphWithSearch(matchingNodes) {
                // Update nodes
                g.selectAll('.node').each(function(d) {
                    const isMatch = matchingNodes.has(d.id);
                    const element = d3.select(this);
                    
                    // Show matching nodes with highlight, fade non-matching
                    element.style('display', 'block')
                           .attr('opacity', isMatch ? 1 : 0.1);
                    
                    if (isMatch) {
                        // Highlight matching nodes
                        const rect = element.select('rect');
                        if (!rect.attr('data-original-color')) {
                            rect.attr('data-original-color', rect.style('stroke'));
                        }
                        rect.style('stroke', '#ff3366')
                            .style('stroke-width', '2px');
                    }
                });

                // Update links
                g.selectAll('.link').each(function(d) {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    const isVisible = matchingNodes.has(sourceId) && matchingNodes.has(targetId);
                    d3.select(this)
                        .style('display', 'block')
                        .attr('opacity', isVisible ? 0.6 : 0.1);
                });

                // If there's exactly one match, zoom to it
                if (matchingNodes.size === 1) {
                    const matchingNode = g.selectAll('.node')
                        .filter(d => matchingNodes.has(d.id))
                        .datum();
                    zoomToNode(matchingNode);
                } else if (matchingNodes.size > 1) {
                    // If there are multiple matches, zoom out to show all matching nodes
                    zoomToFitNodes(Array.from(matchingNodes));
                }
            }

            function zoomToNode(nodeData, scale = 2) {
                if (!nodeData) return;
                
                const x = -nodeData.x * scale + width / 2;
                const y = -nodeData.y * scale + height / 2;
                
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
            }

            function zoomToFitNodes(nodeIds) {
                if (!nodeIds.length) return;

                // Get the positions of all matching nodes
                const nodes = g.selectAll('.node')
                    .filter(d => nodeIds.includes(d.id))
                    .data();

                // Calculate the bounding box
                const bbox = {
                    left: d3.min(nodes, d => d.x),
                    right: d3.max(nodes, d => d.x),
                    top: d3.min(nodes, d => d.y),
                    bottom: d3.max(nodes, d => d.y)
                };

                // Add generous padding (20% of the width/height)
                const dx = bbox.right - bbox.left;
                const dy = bbox.bottom - bbox.top;
                const padding = Math.max(dx, dy) * 0.2;

                // Expand the bounding box with padding
                bbox.left -= padding;
                bbox.right += padding;
                bbox.top -= padding;
                bbox.bottom += padding;
                
                // Calculate the scale to fit the nodes
                const scale = 0.95 * Math.min(
                    width / (bbox.right - bbox.left),
                    height / (bbox.bottom - bbox.top)
                );

                // Calculate center position
                const x = -(bbox.left + bbox.right) / 2 * scale + width / 2 + 100; // Added 300px offset to the right
                const y = -(bbox.top + bbox.bottom) / 2 * scale + height / 2;

                // Animate to the new view
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
            }

            function updateSearchResults(results, searchTerm) {
                if (results.length > 0) {
                    const resultsHtml = results
                        .map(result => {
                            const highlightedName = result.name.replace(
                                new RegExp(searchTerm, 'gi'),
                                match => `<span class="search-result-highlight">${match}</span>`
                            );
                            return `<div class="search-result-item" data-id="${result.id}">${highlightedName}</div>`;
                        })
                        .join('');
                    searchResultsContainer
                        .html(resultsHtml)
                        .style('display', 'block');
                } else {
                    searchResultsContainer
                        .html('<div class="search-result-item">No results found</div>')
                        .style('display', 'block');
                }
            }

            // Handle search result clicks
            searchResultsContainer.on('click', function(event) {
                const resultItem = event.target.closest('.search-result-item');
                if (resultItem) {
                    const nodeId = resultItem.getAttribute('data-id');
                    const node = g.selectAll('.node').filter(d => d.id === nodeId);
                    if (!node.empty()) {
                        const nodeData = node.datum();
                        zoomToNode(nodeData);
                        showPreview(nodeData);
                        searchResultsContainer.style('display', 'none');
                    }
                }
            });

            // Add keyboard navigation for search results
            searchInput.on('keydown', function(event) {
                const results = searchResultsContainer.selectAll('.search-result-item');
                const currentIndex = results.nodes().findIndex(el => el.classList.contains('selected'));
                
                switch(event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        if (results.size()) {
                            const nextIndex = currentIndex < results.size() - 1 ? currentIndex + 1 : 0;
                            results.classed('selected', (d, i) => i === nextIndex);
                            results.nodes()[nextIndex].scrollIntoView({ block: 'nearest' });
                        }
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        if (results.size()) {
                            const prevIndex = currentIndex > 0 ? currentIndex - 1 : results.size() - 1;
                            results.classed('selected', (d, i) => i === prevIndex);
                            results.nodes()[prevIndex].scrollIntoView({ block: 'nearest' });
                        }
                        break;
                    case 'Enter':
                        event.preventDefault();
                        const selectedResult = results.filter('.selected').node();
                        if (selectedResult) {
                            selectedResult.click();
                        } else if (results.size() === 1) {
                            results.node().click();
                        }
                        break;
                }
            });

            // Add styles for keyboard navigation
            const style = document.createElement('style');
            style.textContent = `
                .search-result-item.selected {
                    background-color: #e6f3ff;
                }
                .search-result-item:hover {
                    background-color: #f5f5f5;
                }
                .search-result-item.selected:hover {
                    background-color: #e6f3ff;
                }
            `;
            document.head.appendChild(style);

            // Close search results when clicking outside
            d3.select('body').on('click', function(event) {
                if (!event.target.closest('.search-box')) {
                    searchResultsContainer.style('display', 'none');
                }
            });

            // Add search clear functionality when pressing Escape
            searchInput.on('keyup', function(event) {
                if (event.key === 'Escape') {
                    this.value = '';
                    // Trigger the input event to restore the graph
                    this.dispatchEvent(new Event('input'));
                }
            });

            // Initial graph update
            updateGraph();
            
            // Select the "Radical Art" node immediately
            const radicalArtNode = g.selectAll('.node')
                .filter(d => d.id === 435)
                .datum();
            if (radicalArtNode) {
                selectedNodeId = radicalArtNode.id;
                updateNodeHighlights(radicalArtNode.id);
                showPreview(radicalArtNode);
                
                // Find all connected nodes
                const connectedNodes = new Set();
                simulation.force('link').links().forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (sourceId === radicalArtNode.id) connectedNodes.add(targetId);
                    if (targetId === radicalArtNode.id) connectedNodes.add(sourceId);
                });
                connectedNodes.add(radicalArtNode.id);
                
                // Let the simulation run for a tiny bit to establish initial positions
                simulation.tick(10);
                
                // Now zoom to fit all connected nodes
                zoomToFitNodes(Array.from(connectedNodes));
                
                // Continue the simulation
                simulation.alpha(0.3).restart();
            }
            
            simulation.on('tick', () => {
                g.selectAll('.link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                g.selectAll('.node')
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            function getNodeSize(d) {
                // Use the size property from the backend, fallback to 30 if missing
                const baseSize = d.size || 30;
                const connectionScale = Math.sqrt(nodeDegrees[d.id] || 1);
                // Increase the multiplier for text length and ensure minimum width is larger
                let width = Math.max(150, baseSize + d.cleanName.length * 25) * connectionScale;  // Increased from 150 to 200 and text multiplier from 12 to 15
                let height = Math.max(50, baseSize * 0.4) * connectionScale;
                
                // Add extra padding for Radical Art node
                if (d.isRadicalArt) {
                    width += 40;  // Add 20px padding on each side
                    height += 20; // Add 10px padding on top and bottom
                }
                
                return { width, height };
            }

            function calculateFontSize(d) {
                const size = getNodeSize(d);
                // Keep min size at 12px but increase max size to 80px
                return Math.min(Math.max(size.height * 0.9, 12), 240) + 'px';
            }
            
            function updateNodeSizes() {
                g.selectAll('.node').each(function(d) {
                    const g = d3.select(this);
                    const size = getNodeSize(d);
                    
                    g.select('rect')
                        .attr('width', size.width)
                        .attr('height', size.height)
                        .attr('x', -size.width / 2)
                        .attr('y', -size.height / 2);

                    g.select('text')
                        .style('font-size', calculateFontSize(d));
                });

                // Update collision force radius
                simulation.force('collision').radius(d => getNodeSize(d).width / 1.5);
                simulation.alpha(0.3).restart();
            }

            function zoomed(event) {
                g.attr('transform', event.transform);
            }
            
            function resetView() {
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.scale(initialScale));
            }

            function fitToScreen() {
                if (!g.node()) return;

                // Get the bounds of the graph
                const bounds = g.node().getBBox();
                const fullWidth = bounds.width;
                const fullHeight = bounds.height;
                const midX = bounds.x + fullWidth / 2;
                const midY = bounds.y + fullHeight / 2;

                // Calculate the scale needed to fit the graph
                const scale = 0.75 * Math.min(
                    width / fullWidth,
                    height / fullHeight
                );

                // Calculate the transform needed to center the graph
                const translate = [
                    width / 2 - scale * midX,
                    height / 2 - scale * midY
                ];

                svg.transition()
                    .duration(750)
                    .call(
                        zoom.transform,
                        d3.zoomIdentity
                            .translate(translate[0], translate[1])
                            .scale(scale)
                    );
            }

            // Add click handlers for navigation buttons
            d3.select('#zoomIn').on('click', () => zoomByDelta(0.2));
            d3.select('#zoomOut').on('click', () => zoomByDelta(-0.2));
            d3.select('#resetView').on('click', resetView);
            d3.select('#fitScreen').on('click', fitToScreen);

            // Add background click handler
            svg.on('click', function(event) {
                // Stop event propagation
                event.stopPropagation();
                
                // Get the click coordinates in the zoomed coordinate space
                const [x, y] = d3.pointer(event);
                const transform = d3.zoomTransform(svg.node());
                const zoomedX = (x - transform.x) / transform.k;
                const zoomedY = (y - transform.y) / transform.k;
                
                // Check if we clicked on a node
                let clickedOnNode = false;
                g.selectAll('.node').each(function(d) {
                    const nodeX = d.x;
                    const nodeY = d.y;
                    const size = getNodeSize(d);
                    if (Math.abs(nodeX - zoomedX) < size.width/2 && 
                        Math.abs(nodeY - zoomedY) < size.height/2) {
                        clickedOnNode = true;
                    }
                });
                
                // If we didn't click on a node, deselect
                if (!clickedOnNode) {
                    selectedNodeId = null;
                    updateNodeHighlights(null);
                    d3.select('#preview-panel').style('display', 'none');
                }
            });

            // Add keyboard shortcuts for the new functionality
            d3.select('body').on('keydown', function(event) {
                // Only handle shortcuts if not in an input field
                if (event.target.tagName === 'INPUT') return;
                
                switch(event.key) {
                    case '=':
                    case '+':
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            zoomByDelta(0.2);
                        }
                        break;
                    case '-':
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            zoomByDelta(-0.2);
                        }
                        break;
                    case '0':
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            resetView();
                        }
                        break;
                    case 'f':
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            fitToScreen();
                        }
                        break;
                }
            });

            function zoomByDelta(delta) {
                const currentTransform = d3.zoomTransform(svg.node());
                const newScale = Math.max(0.1, Math.min(4, currentTransform.k + delta));
                
                svg.transition()
                    .duration(300)
                    .call(zoom.scaleTo, newScale);
            }
            
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            function stringToColor(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                }
                let color = '#';
                for (let i = 0; i < 3; i++) {
                    const value = (hash >> (i * 8)) & 0xFF;
                    color += ('00' + value.toString(16)).substr(-2);
                }
                return color;
            }
        }
        
        // Add variable to track selected node
        let selectedNodeId = null;

        // Function to update node highlights based on selection
        function updateNodeHighlights(nodeId) {
            const g = d3.select('svg g');
            if (!g.node()) return;
            
            const connectedNodes = new Set();
            if (nodeId) {
                const currentLinks = d3.selectAll('.link').data();
                currentLinks.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (sourceId === nodeId) connectedNodes.add(targetId);
                    if (targetId === nodeId) connectedNodes.add(sourceId);
                });
                connectedNodes.add(nodeId);
            }
            
            // Update node opacities
            g.selectAll('.node')
                .attr('opacity', n => !nodeId || connectedNodes.has(n.id) ? 1 : 0.1);
            
            // Update link opacities
            g.selectAll('.link')
                .attr('opacity', l => {
                    if (!nodeId) return 0.6;
                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return connectedNodes.has(sourceId) && connectedNodes.has(targetId) ? 1 : 0.1;
                });
        }
        
        createGraph();
    </script>
</body>
</html> 