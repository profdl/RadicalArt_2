<!DOCTYPE html>
<html>
<head>
    <title>Site Link Graph</title>
    <meta charset="utf-8">
    <script>
        // Detect if we're running on GitHub Pages or locally
        window.isGitHubPages = window.location.hostname.includes('github.io');
        window.BASE_PATH = window.isGitHubPages ? '/RadicalArt_2/' : '/';
        document.write(`<base href="${window.BASE_PATH}">`);
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #graph {
            width: 100vw;
            height: 100vh;
            background-color: white;
            position: relative;
        }
        .node rect {
            fill: white;
            stroke: #333;
            stroke-width: 1px;
        }
        .node text {
            font-size: 12px;
            font-family: sans-serif;
            pointer-events: none;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .tooltip {
            position: absolute;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        #controls button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .search-box {
            margin-top: 10px;
            position: relative;
        }
        #search {
            width: 200px;
            padding: 5px 25px 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        #search:focus {
            outline: none;
            border-color: #66afe9;
            box-shadow: 0 0 5px rgba(102, 175, 233, 0.5);
        }
        .search-box::after {
            content: '×';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
            cursor: pointer;
            font-size: 16px;
            display: none;
        }
        .search-box.has-text::after {
            display: block;
        }
        #search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 5px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .search-result-item {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:hover {
            background-color: #f5f5f5;
        }
        .search-result-highlight {
            background-color: #fff3cd;
            padding: 0 2px;
        }
        .search-count {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            display: none;
        }
        #preview-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 400px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            overflow: hidden;
            z-index: 1000;
        }
        #preview-header {
            padding: 10px;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #preview-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #preview-controls button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 5px;
            color: #666;
        }
        #preview-controls button:hover {
            color: #000;
        }
        #preview-title {
            margin: 0;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        #preview-content {
            height: calc(100% - 40px);
            overflow: auto;
        }
        .preview-container {
            transform-origin: top left;
            padding: 10px;
        }
        .preview-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100% - 40px);
            font-style: italic;
            color: #666;
        }
        .checkbox-control {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .checkbox-control input[type="checkbox"] {
            margin: 0;
        }
    </style>
</head>
<body>
    <div id="graph"></div>
    <div class="tooltip"></div>
    <div id="controls">
        <button id="zoomIn">Zoom In</button>
        <button id="zoomOut">Zoom Out</button>
        <button id="resetView">Reset View</button>
        <div class="search-box">
            <input type="text" id="search" placeholder="Search pages...">
            <div class="search-count"></div>
            <div id="search-results"></div>
        </div>
        <div class="checkbox-control">
            <input type="checkbox" id="hideHome" checked>
            <label for="hideHome">Hide Home Page</label>
        </div>
    </div>
    <div id="preview-panel">
        <div id="preview-header">
            <h3 id="preview-title"></h3>
            <div id="preview-controls">
                <button id="preview-zoom-out" title="Zoom Out">−</button>
                <button id="preview-fit" title="Fit to Width">↔</button>
                <button id="preview-zoom-in" title="Zoom In">+</button>
                <button id="preview-close" title="Close">×</button>
            </div>
        </div>
        <div id="preview-content"></div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Use the global variables defined in the head
        const { isGitHubPages, BASE_PATH } = window;

        function getCleanName(path) {
            // Remove .html extension
            path = path.replace('.html', '');
            
            // Split path into parts
            const parts = path.split('/');
            
            // If it ends with index, use the parent directory name
            if (parts[parts.length - 1] === 'index') {
                return parts[parts.length - 2] || parts[0];
            }
            
            // Otherwise use the last meaningful part
            const lastPart = parts[parts.length - 1];
            return lastPart === '' ? parts[parts.length - 2] : lastPart;
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        async function createGraph() {
            const data = await fetch(BASE_PATH + 'graph_data.json').then(response => response.json());
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Calculate node degrees for sizing
            const nodeDegrees = {};
            data.nodes.forEach(node => {
                nodeDegrees[node.id] = 0;
                // Add clean name to node data
                node.cleanName = capitalizeFirstLetter(getCleanName(node.name));
            });
            data.links.forEach(link => {
                nodeDegrees[link.source]++;
                nodeDegrees[link.target]++;
            });
            
            // Store original nodes and links
            const originalNodes = [...data.nodes];
            const originalLinks = [...data.links];
            
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', zoomed);
            
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .call(zoom);
            
            const g = svg.append('g');
            
            let simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id))
                .force('charge', d3.forceManyBody().strength(-1000))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeSize(d).width / 1.5));
            
            function updateGraph(hideHome) {
                // Filter nodes and links if hideHome is true
                let currentNodes = hideHome ? 
                    originalNodes.filter(n => n.name !== 'index.html') : 
                    [...originalNodes];
                
                let currentLinks = hideHome ? 
                    originalLinks.filter(l => {
                        const sourceNode = originalNodes.find(n => n.id === (typeof l.source === 'object' ? l.source.id : l.source));
                        const targetNode = originalNodes.find(n => n.id === (typeof l.target === 'object' ? l.target.id : l.target));
                        return sourceNode && targetNode && 
                               sourceNode.name !== 'index.html' && 
                               targetNode.name !== 'index.html';
                    }) : 
                    [...originalLinks];

                // Update the simulation with new data
                simulation.nodes(currentNodes);
                simulation.force('link').links(currentLinks);
                
                // Update the visual elements
                const link = g.selectAll('.link')
                    .data(currentLinks);
                
                link.exit().remove();
                
                link.enter()
                    .append('line')
                    .attr('class', 'link')
                    .merge(link);
                
                const node = g.selectAll('.node')
                    .data(currentNodes, d => d.id);
                
                node.exit().remove();
                
                const nodeEnter = node.enter()
                    .append('g')
                    .attr('class', 'node')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                nodeEnter.each(function(d) {
                    const g = d3.select(this);
                    const size = getNodeSize(d);
                    
                    g.append('rect')
                        .attr('width', size.width)
                        .attr('height', size.height)
                        .attr('x', -size.width / 2)
                        .attr('y', -size.height / 2)
                        .style('fill', 'white')
                        .style('stroke', d => stringToColor(d.name.split('/')[0] || d.name));
                    
                    g.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .text(d => d.cleanName)
                        .style('font-size', d => Math.min(14, 10 + Math.sqrt(nodeDegrees[d.id])) + 'px');
                });

                // Update existing nodes
                node.select('rect')
                    .attr('width', d => getNodeSize(d).width)
                    .attr('height', d => getNodeSize(d).height)
                    .attr('x', d => -getNodeSize(d).width / 2)
                    .attr('y', d => -getNodeSize(d).height / 2);

                node.select('text')
                    .text(d => d.cleanName)
                    .style('font-size', d => Math.min(14, 10 + Math.sqrt(nodeDegrees[d.id])) + 'px');

                // Set up node event handlers
                const allNodes = node.merge(nodeEnter);
                const allLinks = link.merge(link.enter());

                allNodes.on('mouseover', function(event, d) {
                    tooltip.style('display', 'block')
                        .html(`${d.name}<br/>${nodeDegrees[d.id]} connections`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                    
                    const connectedNodes = new Set();
                    currentLinks.forEach(link => {
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        if (sourceId === d.id) connectedNodes.add(targetId);
                        if (targetId === d.id) connectedNodes.add(sourceId);
                    });
                    
                    // Update node opacities
                    g.selectAll('.node')
                        .attr('opacity', n => connectedNodes.has(n.id) || n.id === d.id ? 1 : 0.1);
                    
                    // Update link opacities
                    g.selectAll('.link')
                        .attr('opacity', l => {
                            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                            return sourceId === d.id || targetId === d.id ? 1 : 0.1;
                        });
                })
                .on('mouseout', function() {
                    tooltip.style('display', 'none');
                    // Reset opacities
                    g.selectAll('.node').attr('opacity', 1);
                    g.selectAll('.link').attr('opacity', 0.6);
                })
                .on('click', function(event, d) {
                    // Zoom to node
                    const scale = 2;
                    const x = -d.x * scale + width / 2;
                    const y = -d.y * scale + height / 2;
                    svg.transition().duration(750)
                        .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
                    
                    // Show preview panel
                    showPreview(d);
                });

                // Restart the simulation
                simulation.alpha(1).restart();
            }

            // Move the showPreview function definition here
            function showPreview(d) {
                const previewPanel = d3.select('#preview-panel');
                const previewTitle = d3.select('#preview-title');
                const previewContent = d3.select('#preview-content');
                
                // Set the title
                previewTitle.text(d.cleanName);
                
                // Show loading state
                previewContent.html('<div class="preview-loading">Loading preview...</div>');
                previewPanel.style('display', 'block');

                // Handle the file path
                const filePath = d.name;
                
                // Add close button functionality
                d3.select('#preview-close').on('click', () => {
                    previewPanel.style('display', 'none');
                });

                // First try to fetch the content
                fetch(BASE_PATH + filePath)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`File not found: ${d.name}`);
                        }
                        return response.text();
                    })
                    .then(content => {
                        // Create a container for the content
                        const container = document.createElement('div');
                        container.className = 'preview-container';
                        container.style.width = 'max-content';
                        container.style.minWidth = '100%';
                        container.style.transform = 'scale(1)';
                        
                        try {
                            // Parse the content with DOMParser to manipulate it before inserting
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            
                            // Remove blacktext.html references before they can trigger requests
                            doc.querySelectorAll('link[href*="blacktext.html"]').forEach(el => el.remove());
                            
                            // Add default styles
                            const defaultStyle = document.createElement('style');
                            defaultStyle.textContent = `
                                body {
                                    font-family: Arial, sans-serif;
                                    color: #000;
                                    background: #fff;
                                    margin: 0;
                                    padding: 10px;
                                }
                                a {
                                    color: #0066cc;
                                    text-decoration: none;
                                }
                                a:hover {
                                    text-decoration: underline;
                                }
                                img {
                                    max-width: 100%;
                                    height: auto;
                                }
                                .broken-image {
                                    display: inline-block;
                                    background: #f0f0f0;
                                    border: 1px dashed #999;
                                    padding: 10px;
                                    color: #666;
                                    font-style: italic;
                                    font-size: 12px;
                                    text-align: center;
                                    min-width: 100px;
                                    min-height: 50px;
                                    line-height: 50px;
                                }
                            `;
                            doc.head.appendChild(defaultStyle);
                            
                            // Set the HTML content
                            container.innerHTML = doc.documentElement.innerHTML;
                            
                            // Clear the preview content and add the container
                            previewContent.html('');
                            previewContent.node().appendChild(container);
                            
                            // Fix relative paths in the content
                            const currentPath = filePath.substring(0, filePath.lastIndexOf('/') + 1);
                            
                            // Handle all resources
                            container.querySelectorAll('img, link[rel="stylesheet"], script').forEach(el => {
                                if (el.tagName.toLowerCase() === 'img') {
                                    const originalSrc = el.getAttribute('src');
                                    if (originalSrc && !originalSrc.startsWith('http')) {
                                        // Try to load the image relative to the current page
                                        const imgPath = originalSrc.startsWith('/') ? 
                                            BASE_PATH + originalSrc.substring(1) : 
                                            BASE_PATH + currentPath + originalSrc;
                                        el.src = imgPath;
                                        el.onerror = () => handleResourceError(el, originalSrc);
                                    }
                                } else if (el.src && !el.src.startsWith('http')) {
                                    const srcPath = el.src.startsWith('/') ? el.src.substring(1) : el.src;
                                    el.src = BASE_PATH + srcPath;
                                }
                                if (el.href && !el.href.startsWith('http')) {
                                    // Skip blacktext.html completely
                                    if (el.href.includes('blacktext.html')) {
                                        el.remove();
                                        return;
                                    }
                                    const hrefPath = el.href.startsWith('/') ? el.href.substring(1) : el.href;
                                    el.href = BASE_PATH + hrefPath;
                                }
                            });

                            // Function to fit content to width
                            function fitToWidth() {
                                const contentWidth = container.scrollWidth;
                                const containerWidth = previewContent.node().clientWidth;
                                const scale = Math.min(1, (containerWidth - 20) / contentWidth);
                                container.style.transform = `scale(${scale})`;
                            }

                            // Initial fit to width
                            setTimeout(fitToWidth, 100);

                            // Add zoom controls
                            let currentScale = 1;
                            
                            d3.select('#preview-zoom-in').on('click', () => {
                                currentScale = Math.min(2, currentScale + 0.1);
                                container.style.transform = `scale(${currentScale})`;
                            });
                            
                            d3.select('#preview-zoom-out').on('click', () => {
                                currentScale = Math.max(0.1, currentScale - 0.1);
                                container.style.transform = `scale(${currentScale})`;
                            });
                            
                            d3.select('#preview-fit').on('click', fitToWidth);
                        } catch (error) {
                            console.error('Error processing preview content:', error);
                            showErrorPreview(d.name, error.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading preview:', error);
                        showErrorPreview(d.name, error.message);
                    });
            }

            function showErrorPreview(filename, errorMessage) {
                const previewContent = d3.select('#preview-content');
                previewContent.html(`
                    <div class="preview-error" style="padding: 20px; text-align: center;">
                        <h3 style="color: #666;">Unable to Preview File</h3>
                        <p style="color: #888;">${filename}</p>
                        <p style="color: #999; font-style: italic;">${errorMessage}</p>
                        <div style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 5px;">
                            <p style="margin: 0; color: #666;">This file might be:</p>
                            <ul style="list-style: none; padding: 0; margin: 10px 0;">
                                <li style="color: #888;">• Not accessible from the current location</li>
                                <li style="color: #888;">• Moved or deleted</li>
                                <li style="color: #888;">• Requiring special permissions</li>
                            </ul>
                        </div>
                    </div>
                `);
            }

            function handleResourceError(element, originalSrc) {
                if (!originalSrc) return;
                
                // Get the image name and check if it's in a concept path
                const imgName = originalSrc.split('/').pop();
                
                // Build the list of paths to try, starting with most likely locations
                const alternativePaths = [
                    // Artist-specific paths first
                    `${BASE_PATH}anything/OpenForm/Rauschenberg/${imgName}`,
                    `${BASE_PATH}images/${imgName}`,
                    `${BASE_PATH}img/${imgName}`,
                    `${BASE_PATH}assets/${imgName}`,
                    `${BASE_PATH}gif/buttons/${imgName}`,
                    `${BASE_PATH}gif/kinetiek/${imgName}`,
                    `${BASE_PATH}gif/natuur/${imgName}`,
                    `${BASE_PATH}gif/${imgName}`,
                    `${BASE_PATH}${imgName}`
                ];

                // Add artist-specific paths if the image name contains artist names
                const artistPaths = {
                    'Rauschenberg': 'anything/OpenForm/Rauschenberg',
                    'Agam': 'Agam',
                    'PaulTalman': 'PaulTalman',
                    'JanHenderikse': 'JanHenderikse',
                    'ReinerKallhardt': 'ReinerKallhardt'
                };

                Object.entries(artistPaths).forEach(([artist, path]) => {
                    if (imgName.includes(artist)) {
                        alternativePaths.unshift(`${BASE_PATH}${path}/${imgName}`);
                    }
                });
                
                // Try each path in sequence
                async function tryNextPath(index = 0) {
                    if (index >= alternativePaths.length) {
                        console.error('Could not find image:', imgName);
                        element.outerHTML = `<div class="broken-image">Image not found: ${imgName}</div>`;
                        return;
                    }
                    
                    const path = alternativePaths[index];
                    try {
                        const response = await fetch(path, { method: 'HEAD' });
                        if (response.ok) {
                            element.src = path;
                            return;
                        }
                    } catch (error) {
                        // Continue to next path
                    }
                    await tryNextPath(index + 1);
                }
                
                tryNextPath();
            }

            // Add event listener for the checkbox
            d3.select('#hideHome').on('change', function() {
                updateGraph(this.checked);
            });

            // Add search functionality
            const searchInput = d3.select('#search');
            const searchBox = d3.select('.search-box');
            const searchCount = d3.select('.search-count');
            const searchResultsContainer = d3.select('#search-results');

            // Clear search when clicking the × button
            searchBox.on('click', function(event) {
                const target = event.target;
                if (target.tagName !== 'INPUT' && searchInput.node().value) {
                    searchInput.node().value = '';
                    searchInput.node().dispatchEvent(new Event('input'));
                    event.stopPropagation();
                }
            });

            searchInput.on('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                // Update search box clear button visibility
                searchBox.classed('has-text', searchTerm.length > 0);
                
                // If search is empty, restore all nodes to original state
                if (!searchTerm) {
                    restoreGraphState();
                    return;
                }

                // Get all nodes that match the search term
                const matchingNodes = new Set();
                const matchingResults = [];

                // Search through nodes
                g.selectAll('.node').each(function(d) {
                    const nodeText = d.name.toLowerCase();
                    const cleanName = d.cleanName.toLowerCase();
                    if (nodeText.includes(searchTerm) || cleanName.includes(searchTerm)) {
                        matchingNodes.add(d.id);
                        matchingResults.push({
                            id: d.id,
                            name: d.name,
                            cleanName: d.cleanName,
                            node: d
                        });
                    }
                });

                // Update search count
                const matchCount = matchingNodes.size;
                searchCount.text(`Found ${matchCount} match${matchCount !== 1 ? 'es' : ''}`)
                    .style('display', 'block');

                // Update graph visualization
                updateGraphWithSearch(matchingNodes);

                // Update search results dropdown
                updateSearchResults(matchingResults, searchTerm);
            });

            function restoreGraphState() {
                // Reset node visibility and styling
                g.selectAll('.node')
                    .style('display', 'block')
                    .attr('opacity', 1)
                    .each(function() {
                        const rect = d3.select(this).select('rect');
                        const originalColor = rect.attr('data-original-color');
                        if (originalColor) {
                            rect.style('stroke', originalColor)
                                .style('stroke-width', '1px')
                                .attr('data-original-color', null);
                        }
                    });

                // Reset link visibility
                g.selectAll('.link')
                    .style('display', 'block')
                    .attr('opacity', 0.6);

                // Hide search UI elements
                searchCount.style('display', 'none');
                searchResultsContainer.style('display', 'none');
            }

            function updateGraphWithSearch(matchingNodes) {
                // Update nodes
                g.selectAll('.node').each(function(d) {
                    const isMatch = matchingNodes.has(d.id);
                    const element = d3.select(this);
                    
                    // Show matching nodes with highlight, fade non-matching
                    element.style('display', 'block')
                           .attr('opacity', isMatch ? 1 : 0.1);
                    
                    if (isMatch) {
                        // Highlight matching nodes
                        const rect = element.select('rect');
                        if (!rect.attr('data-original-color')) {
                            rect.attr('data-original-color', rect.style('stroke'));
                        }
                        rect.style('stroke', '#ff3366')
                            .style('stroke-width', '2px');
                    }
                });

                // Update links
                g.selectAll('.link').each(function(d) {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    const isVisible = matchingNodes.has(sourceId) && matchingNodes.has(targetId);
                    d3.select(this)
                        .style('display', 'block')
                        .attr('opacity', isVisible ? 0.6 : 0.1);
                });

                // If there's exactly one match, zoom to it
                if (matchingNodes.size === 1) {
                    const matchingNode = g.selectAll('.node')
                        .filter(d => matchingNodes.has(d.id))
                        .datum();
                    zoomToNode(matchingNode);
                } else if (matchingNodes.size > 1) {
                    // If there are multiple matches, zoom out to show all matching nodes
                    zoomToFitNodes(Array.from(matchingNodes));
                }
            }

            function zoomToNode(nodeData, scale = 2) {
                if (!nodeData) return;
                
                const x = -nodeData.x * scale + width / 2;
                const y = -nodeData.y * scale + height / 2;
                
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
            }

            function zoomToFitNodes(nodeIds) {
                if (!nodeIds.length) return;

                // Get the positions of all matching nodes
                const nodes = g.selectAll('.node')
                    .filter(d => nodeIds.includes(d.id))
                    .data();

                // Calculate the bounding box
                const bbox = {
                    left: d3.min(nodes, d => d.x),
                    right: d3.max(nodes, d => d.x),
                    top: d3.min(nodes, d => d.y),
                    bottom: d3.max(nodes, d => d.y)
                };

                // Add padding
                const padding = 50;
                const dx = bbox.right - bbox.left + padding * 2;
                const dy = bbox.bottom - bbox.top + padding * 2;
                
                // Calculate the scale to fit the nodes
                const scale = Math.min(
                    width / dx,
                    height / dy,
                    2 // Maximum zoom level
                );

                // Calculate center position
                const x = -(bbox.left + bbox.right) / 2 * scale + width / 2;
                const y = -(bbox.top + bbox.bottom) / 2 * scale + height / 2;

                // Animate to the new view
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
            }

            function updateSearchResults(results, searchTerm) {
                if (results.length > 0) {
                    const resultsHtml = results
                        .map(result => {
                            const highlightedName = result.name.replace(
                                new RegExp(searchTerm, 'gi'),
                                match => `<span class="search-result-highlight">${match}</span>`
                            );
                            return `<div class="search-result-item" data-id="${result.id}">${highlightedName}</div>`;
                        })
                        .join('');
                    searchResultsContainer
                        .html(resultsHtml)
                        .style('display', 'block');
                } else {
                    searchResultsContainer
                        .html('<div class="search-result-item">No results found</div>')
                        .style('display', 'block');
                }
            }

            // Handle search result clicks
            searchResultsContainer.on('click', function(event) {
                const resultItem = event.target.closest('.search-result-item');
                if (resultItem) {
                    const nodeId = resultItem.getAttribute('data-id');
                    const node = g.selectAll('.node').filter(d => d.id === nodeId);
                    if (!node.empty()) {
                        const nodeData = node.datum();
                        zoomToNode(nodeData);
                        showPreview(nodeData);
                        searchResultsContainer.style('display', 'none');
                    }
                }
            });

            // Add keyboard navigation for search results
            searchInput.on('keydown', function(event) {
                const results = searchResultsContainer.selectAll('.search-result-item');
                const currentIndex = results.nodes().findIndex(el => el.classList.contains('selected'));
                
                switch(event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        if (results.size()) {
                            const nextIndex = currentIndex < results.size() - 1 ? currentIndex + 1 : 0;
                            results.classed('selected', (d, i) => i === nextIndex);
                            results.nodes()[nextIndex].scrollIntoView({ block: 'nearest' });
                        }
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        if (results.size()) {
                            const prevIndex = currentIndex > 0 ? currentIndex - 1 : results.size() - 1;
                            results.classed('selected', (d, i) => i === prevIndex);
                            results.nodes()[prevIndex].scrollIntoView({ block: 'nearest' });
                        }
                        break;
                    case 'Enter':
                        event.preventDefault();
                        const selectedResult = results.filter('.selected').node();
                        if (selectedResult) {
                            selectedResult.click();
                        } else if (results.size() === 1) {
                            results.node().click();
                        }
                        break;
                }
            });

            // Add styles for keyboard navigation
            const style = document.createElement('style');
            style.textContent = `
                .search-result-item.selected {
                    background-color: #e6f3ff;
                }
                .search-result-item:hover {
                    background-color: #f5f5f5;
                }
                .search-result-item.selected:hover {
                    background-color: #e6f3ff;
                }
            `;
            document.head.appendChild(style);

            // Close search results when clicking outside
            d3.select('body').on('click', function(event) {
                if (!event.target.closest('.search-box')) {
                    searchResultsContainer.style('display', 'none');
                }
            });

            // Add search clear functionality when pressing Escape
            searchInput.on('keyup', function(event) {
                if (event.key === 'Escape') {
                    this.value = '';
                    // Trigger the input event to restore the graph
                    this.dispatchEvent(new Event('input'));
                }
            });

            // Initial graph update
            updateGraph(true);
            
            const tooltip = d3.select('.tooltip');
            
            simulation.on('tick', () => {
                g.selectAll('.link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                g.selectAll('.node')
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            function getNodeSize(d) {
                // Use the size property from the backend, fallback to 30 if missing
                const baseSize = d.size || 30;
                return {
                    width: Math.max(60, baseSize + d.cleanName.length * 8),
                    height: Math.max(25, baseSize * 0.4)
                };
            }
            
            function zoomed(event) {
                g.attr('transform', event.transform);
            }
            
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            function stringToColor(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                }
                let color = '#';
                for (let i = 0; i < 3; i++) {
                    const value = (hash >> (i * 8)) & 0xFF;
                    color += ('00' + value.toString(16)).substr(-2);
                }
                return color;
            }
        }
        
        createGraph();
    </script>
</body>
</html> 